{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#install","title":"Install","text":"<pre><code># via pip\npip install xinject\n\n# via poetry\npoetry add xinject\n</code></pre>"},{"location":"#introduction","title":"Introduction","text":"<p>Main focus is an easy way to create lazy universally injectable dependencies; in less magical way. It also leans more on the side of making it easier to get the dependency you need anywhere in the codebase.</p> <p>py-xinject allows you to easily inject lazily created universal dependencies into whatever code that needs them, in an easy to understand and self-documenting way.</p> xinject is short for \"Universal Dependency\" <p>ie: a lazy universally injectable dependency</p> Note <p>Read this document first to get a general overview before reading the API reference documentation.</p> <p>When you're done here and want more details go to API Reference or directly to <code>Dependency API Refrence</code> for more detailed reference-type documentation.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Although it's not required, most of the time you'll want to subclass <code>Dependency</code>. The subclass will inherit some nice features that make it easier to use.</p> <p>The following is a specific usecase followed by a more generalized example</p>"},{"location":"#lazy-s3-resource-dependency-example","title":"Lazy S3 Resource Dependency Example","text":"<p>Here is a very basic injectable/sharable lazily created S3 resource.</p> <p>We have a choice to inherit from ether Dependency, or DependencyPerThread.</p> <p>The normal <code>Dependency</code> class lets the dependency be shared between threads, so more of a true singleton type of object where under normal/default circomstances there would ever only be one instance of a partculare <code>Dependency</code>.</p> <p>Using <code>DependencyPerThread</code> will automatically get a separate dependency object per-thread (ie: separate instance per-thread). It simply inherits from Dependency and configures it to not be thread sharable.</p> <p>In the example below, we do that with the Boto resource, as the boto documentation for resources states they are not thread-safe. That means our program will need a separate s3 resource per-thread.</p> <pre><code># This is the \"my_resources.py\" file/module.\n\nimport boto3\nfrom xinject import DependencyPerThread\n\n\nclass S3(DependencyPerThread):\n    def __init__(self, **kwargs):\n        # Keeping this simple; a more complex version\n        # may store the `kwargs` and lazily create the s3 resource\n        # only when it's asked for (via a `@property or some such).\n\n        self.resource = boto3.resource('s3', **kwargs)\n</code></pre> <p>To use this resource in any codebase, you can do this:</p> <pre><code># This is the \"my_functions.py\" file/module\n\nfrom .my_resources import S3\n\ndef download_file(file_name, dest_path):\n    s3_resource = S3.grab().resource\n    s3_resource.Bucket('my-bucket').download_file(\n        file_name, dest_path\n    )\n</code></pre> <p>When <code>grab_file</code> is called it will grab the current <code>S3</code> dependency and get the resource off of it. If <code>S3</code> dependency has not been created yet, it will do so on the fly and store and return the lazily created dependency in the future when asked for it.</p> <p>This means, the resource is only created when it needs to be.</p>"},{"location":"#inject-temporarily","title":"Inject Temporarily","text":"<p>Now, let's say you wanted to change/inject a different version of the S3 dependency, you could do this:</p> <pre><code>from .my_resources import S3\nfrom .my_functions import download_file\n\nus_west_s3_resource = S3(region_name='us-west-2')\n\ndef get_s3_file_from_us_west(file, dest_path):\n    # Can use Dependencies as a context-manager,\n    # inject `use_west_s3_resource` inside `with`:\n    with us_west_s3_resource:\n        download_file(file, dest_path)\n\n# Can also use Dependencies as a function decorator,\n# inject `use_west_s3_resource` whenever this method is called.\n@us_west_s3_resource\ndef get_s3_file_from_us_west(file, dest_path):\n    download_file(file, dest_path)\n</code></pre> <p>All classes that inherit from <code>Dependency</code> are context managers, and so the <code>with</code> statement will 'activate' that dependency as the current version to use.</p> <p>That will inject an S3 resource configured with <code>region_name='us-west-2</code> into the function you are calling.</p> <p>It does not matter how many other methods needs to be called to get to the method that needs the <code>S3</code> resource, it would still be injected and used.</p> <p>After the <code>with</code> statement is exited, the previous <code>S3</code> instance (if any) that was active before the <code>with</code> statement is now what is used from that point forward.</p> <p>This allows you to decouple the code. Code that needs a resource can grab it from the S3 class, and code that needs to configure the resource can do so without having to know exactly what other methods needs that dependency. It can configure the dependencies as/if needed, start the app/process and be done.</p> <p>The resource also sticks around inside the dependency, and can be reused/shared. This allows the boto3 s3 resource (in the example above) to reuse already opened TCP connections to s3 as the s3 resource is used from various parts of the code base.</p>"},{"location":"#inject-permanently","title":"Inject Permanently","text":"<p>If instead (see previous example) you don't want to temporarily inject a dependency, but instead permanently do it you can do so in a few ways:</p> <ul> <li>Change the current dependency by setting attributes or calling methods on it.</li> <li>Replace the current dependency with a different object.</li> </ul> <p>The first way is easy, you just access the current version of the resource. I'll be using the <code>S3</code> dependency from the previous example:</p> <pre><code>from .my_resources import S3\nS3.grab().resource = boto.resource('s3', region_name='us-west-2')\n</code></pre> <p>In this case, I am replacing the <code>resource</code> attribute on the S3 current dependency instance/object with my own version of the resource. From this point forward, it will be what is used (unless some other code after this point temporarily injects their own resource via a <code>with</code>; see previous example).</p> <p>Fro the second way, you can access the repository of dependencies  and swap/inject a different resource there.</p> <p>This will add the dependency to the current context, and when that  dependency is next asked for it will return the one that was added here:</p> <pre><code>from xinject import XContext\nfrom .my_resources import S3\n\nus_west_s3_resource = S3(region_name='us-west-2')\nXContext.grab().add(us_west_s3_resource)\n</code></pre> <p>And finally, you can replace dependencies with a completely different class of object. This is sometimes useful when doing unit-testing.</p> <p>What we do here is add out special MyS3MockingClass object and tell context to use this in place for the <code>S3</code> type dependency.</p> <p>In the future, this mocking object will be returned when the code asks for the <code>S3</code> dependency-type.</p> <pre><code>from xinject import XContext\nfrom .my_resources import S3\nfrom .my_mocks import MyS3MockingClass\n\ns3_mocking_obj = MyS3MockingClass()\nXContext.grab().add(s3_mocking_obj, for_type=S3)\n</code></pre>"},{"location":"#generalizedgeneric-example","title":"Generalized/Generic Example","text":"<p>Although it's not required, most of the time you'll want to subclass <code>Dependency</code>. The subclass will inherit some nice features that make it easier to use.</p> <pre><code>from xinject import Dependency\n\n# This is an example Dependency class, the intent with this class\n# is to treat it as a semi-singleton shared dependency.\nclass MyUniversalDependency(Dependency):\n\n  # It's important to allow dependencies to be allocated with\n  # no required init arguments.\n  # That way a default-instance/version of the class can\n  # easily be created lazily.\n  def __init__(self, name=None):\n    if name is not None:\n      self.name = name\n\n  name: str = 'original-value'\n\n\n# Gets currently active instance of `MyUniversalDependency`,\n# or lazily creates if needed. If system creates a new\n# instance of MyUniversalDependency, it will save it and\n# reuse it in the future when it's asked for.\n#\n# Next, we get value of it's `name` attribute:\n\nassert MyUniversalDependency.grab().name == 'original-value'\n\n# Change the value of the name attribute on current dependency\nMyUniversalDependency.grab().name = 'changed-value'\n\n# We still have access to the same object, so it has the new value:\nassert MyUniversalDependency.grab().name == 'changed-value'\n\n# Inherit from Dependency allows you to use them as a context manager.\n# This allows you to easily/temporarily inject dependencies:\n\nwith MyUniversalDependency(name='injected-value'):\n  # When someone asks for the current dependency of `MyResource`,\n  # they will get the one I created in `with` statement above.\n\n  assert MyUniversalDependency.grab().name == 'injected-value'\n\n# Object we created and temporary activated/injected\n# by above `with` statement has been deactivated/uninjected.\n# So, the previous object is what is now used:\n\nassert MyUniversalDependency.grab().name == 'changed-value'\n</code></pre> <p>There is also a way to get a proxy-object that represents the currently used object.</p> <p>This allows you to have an object that is directly importable/usable and still have it be injectable.</p> <pre><code>from xinject import Dependency\n\n\nclass MyUniversalDependency(Dependency):\n    def __init__(self, name='default-value'):\n        self.name = name\n\n\nmy_universal_dependency = MyUniversalDependency.proxy()\n\nassert my_universal_dependency.name == 'changing-the-value'\n\nwith MyUniversalDependency(name='injected-value'):\n    # The proxy object proxies to the currently activated/injected\n    # version of the dependency:\n    assert my_universal_dependency.name == 'injected-value'\n</code></pre>"},{"location":"#overview","title":"Overview","text":"<p>The main class used most of the time is <code>Dependency</code>.</p> <p>Allows you to create sub-classes that act as sharable singleton-type objects that we are calling resources here. These are also typically objects that should generally stick around and should be created lazily.</p> <p>Also allows code to temporarily create, customize and activate a dependency if you don't want the customization to stick around permanently. You can do it without your or other code needing to be aware of each other.</p> <p>This helps promote code decoupling, since it's so easy to make a Dependency activate it as the 'current' version to use.</p> <p>The only coupling that takes place is to the Dependency sub-class it's self.</p> <p>Each separate piece of code can be completely unaware of each other, and yet each one can take advantage of the shared dependency.</p> <p>This means that Dependency can also help with simple dependency injection use-case scenarios.</p>"},{"location":"#what-its-used-for","title":"What It's Used For","text":"<ul> <li>Lazily created singleton-type objects that you can still override/inject as needed in a decoupled fashion.</li> <li>Supports foster decoupled code by making it easy to use dependency injection code patterns.<ul> <li>Lazily created resources, like api clients.</li> <li>Helps with unit testing mock frameworks.<ul> <li>Example: moto needs boto clients to be created after unit test starts, so it can intercept and mock it.</li> <li>Using a dependency to get boto client allows them to be lazily created/mocked during each unit-test run.</li> </ul> </li> </ul> </li> <li>Lazily create sharable objects on demand when/where needed.<ul> <li>Things that need to be shared in many locations, without having to pass them everywhere, or couple the code together.</li> <li>Example: session from requests library, so code can re-use already open TCP connections to an API.</li> </ul> </li> </ul>"},{"location":"#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Network connection and/or a remote dependency/client.<ul> <li>You can wrap these objects in a <code>dependency</code>, the dependency provides the object.</li> <li>Objects to wrap are 'client' like things, and allow you to communicate with some external system.</li> <li>Very common for these objects to represent an already-open network connection,   So there are performance considerations to try and keep connection open and to reuse it.</li> </ul> </li> <li>Common configuration or setting objects.</li> <li>Anything that needs to be lazily allocated,   especially if they need to be re-created for each unit-test run.<ul> <li>Since all dependencies are thrown-away before running each unit-test function,   all dependencies will be lazily re-created each time by default.</li> <li>Examples:<ul> <li>moto<ul> <li>You need to create boto clients after moto is setup in order for moto to intercept/mock   the service the boto client uses.</li> <li>But you also don't want the main code base to create a brand new boto client each time it needs it,   so that it can reuse/share already established TCP connections.</li> <li>Using a Dependency to lazily manage your boto clients solves both of these issues.</li> </ul> </li> <li>requests-mock<ul> <li>Requests-mock needs to be in place before the code base creates a requests-session<ul> <li>You want to use a session in main code base to reuse/share already established TCP connections   to your http apis.</li> </ul> </li> <li>Using a Dependency to manage a shared requests session lets you both lazily create the session to help   with unit testing, but also allows you to easily reuse the session in your codebase in a decoupled manner.</li> </ul> </li> </ul> </li> </ul> </li> <li>Basic dependency injection scenarios, where two separate pieces of code need to use a shared   object of some sort that you want to 'inject' into them.<ul> <li>Does it in a way that prevents you having to pass around the object manually everywhere.</li> <li>Promotes code-decoupling, since there is less-temptation to couple them if it's easy to share   what they need between each-other, without having each piece of code having to know about each-other.</li> </ul> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#141-2025-11-06","title":"1.4.1 (2025-11-06)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Inform pydantic this is a class-var, and should not be messed with. (523a9a3)</li> <li>license (709f49e)</li> <li>only return any particular object once in a dependency-chain call. (f3c9b0a)</li> </ul>"},{"location":"changelog/#141-2023-04-15","title":"1.4.1 (2023-04-15)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>license (709f49e)</li> </ul>"},{"location":"changelog/#140-2023-02-19","title":"1.4.0 (2023-02-19)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>have proxy also forward set/get item dunder methods. (e471b71)</li> </ul>"},{"location":"changelog/#130-2023-02-03","title":"1.3.0 (2023-02-03)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>added ability to easily proxy an attribute on dependency. (0ff42a0)</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>style, add doc comment. (3ad3817)</li> </ul>"},{"location":"changelog/#120-2023-01-02","title":"1.2.0 (2023-01-02)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>renamed resource-refs to dependency-refs terminology; ie: <code>resource_chain() -&amp;gt; dependency_chain()</code> (f1f7b08)</li> </ul>"},{"location":"changelog/#110-2022-12-13","title":"1.1.0 (2022-12-13)","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>update deps. (0c49054)</li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>fixes a bug where if you activate a dependency before the thread-root context is created. (0bb778c)</li> </ul>"},{"location":"changelog/#102-2022-11-20","title":"1.0.2 (2022-11-20)","text":""},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>fix readme pypi pointer. (e775c81)</li> </ul>"},{"location":"changelog/#101-2022-11-20","title":"1.0.1 (2022-11-20)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>add missing metadata to package. (ced4cea)</li> </ul>"},{"location":"changelog/#100-2022-11-20","title":"1.0.0 (2022-11-20)","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>release as version 1.0.0 (a971752)</li> </ul>"},{"location":"changelog/#040-2022-11-20","title":"0.4.0 (2022-11-20)","text":""},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>added <code>obj</code> class property on Dependency to more easily get current dependency object. (e7de56e)</li> <li>precent context from copying unless needed. (3e0940c)</li> <li>Proxy str/repr functions. (0991475)</li> <li>rearranged docs to make them more clear. (2d55d38)</li> <li>rename ActiveResourceProxy to CurrentDependencyProxy (5474533)</li> <li>rename file to new name. (e5bf973)</li> <li>rename library to final name <code>xinject</code>. (be567e4)</li> <li>renamed <code>resource()</code> into <code>grab()</code>, a simpler and more obvious name for what it does. (aafcec8)</li> <li>renamed glazy into udepend in general. (f302abe)</li> <li>renamed guards to xsentinels. (750d987)</li> <li>return self if calling dependency without args (supports future Dependency.grab() syntax). (c2ebe5b)</li> <li>simplified <code>grab</code> method; updated doc-comment; renamed to DependecyPerThread. (40a2052)</li> </ul>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>doc links (4d0fdb0)</li> <li>doc-comments + thread-sharable feature. (2da6a76)</li> <li>forgot to rename UDependError to XInjectError. (7c4bf11)</li> <li>more emphasis on doc-link. (325a191)</li> <li>use NotImplementedError instead of just NotImplemented. (24dbaa0)</li> </ul>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>capitalized API Reference (a82f9ed)</li> <li>fix readme. (f2990d5)</li> <li>fix references to <code>Context</code> to fully qualified <code>UContext</code>. (6558f12)</li> <li>grammer fix (c40f472)</li> <li>Majorly improve documentation. (5b0af23)</li> <li>splitting up docs into multiple files. (71fee52)</li> </ul>"},{"location":"changelog/#030-2022-10-08","title":"0.3.0 (2022-10-08)","text":""},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>add api docs ref, change-log... (f3ffaed)</li> <li>add docs. (bec0deb)</li> </ul>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>accidentally added .html files... (4fb10b4)</li> <li>remove unneeded input to reusable workflow call. (040e4fd)</li> <li>test-release-process. (b9c6d8c)</li> </ul>"},{"location":"changelog/#020-2022-10-08","title":"0.2.0 (2022-10-08)","text":""},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>initial code import; experimental; DO NOT USE!!! (ace5177)</li> </ul>"},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>correct package to include name. (2d481b4)</li> </ul>"},{"location":"changelog/#010-2022-10-08","title":"0.1.0 (2022-10-08)","text":""},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>initial code import; experimental; DO NOT USE!!! (ace5177)</li> </ul>"},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>correct package to include name. (2d481b4)</li> </ul>"},{"location":"dataclasses/","title":"Data Classes","text":""},{"location":"dataclasses/#dependency-dataclasses","title":"Dependency + Dataclasses","text":"<p>You can use the built-in dataclasses with Dependency without a problem. Just ensure all fields are optional (ie: they all have default values), so they are not required when creating/init'ing the object.</p> <p>You can also provide a <code>__post_init__</code> method on your <code>Dependency</code> subclass to help you initialize the values into a good default state (a standard feature of dataclasses).</p> <p>The purpose to enable lazily creation of the Dependency object the very first time it's asked for.</p> <p>Example:</p> <pre><code>from xinject import Dependency\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass DataResource(Dependency):\n    # Making all fields optional, so DataResource can be created lazily:\n    my_optional_field: str = None\n    another_optional_field: str = \"hello!\"\n\n\n# Get current DataResource dependency, print it's another_optional_field;\n# will print out `hello!`:\nprint(DataResource.grab().another_optional_field)\n\nDataResource.grab()\n\nDataResource.grab()\n\nDataResource.grab()\n</code></pre>"},{"location":"dependency-proxy/","title":"Dependency Proxy","text":"<p>You can use the method <code>Dependency.proxy()</code> to easily get a proxy object.</p> <p>All non-dunder attributes/methods will be grabbed/set on the current object instead of the proxy.</p> <p>This means you can call all non-special methods and access normal attributes, as if the object was really the currently active dependency instance.</p> <p>Any methods/attributes that start with a <code>_</code> will not be used on the proxied object, but will be used on only the proxy-object it's self. This means, you should not ask/set any attributes that start with <code>_</code> (underscore) when using the proxy object.</p> <p>Here is an example boto3 s3 resource dependency:</p> <pre><code># This is the \"my_resources.py\" file/module.\n\nfrom xinject import Dependency\n\nimport boto3\nfrom xinject import DependencyPerThread\n\n\nclass S3(DependencyPerThread):\n    def __init__(self, **kwargs):\n        self.resource = boto3.resource('s3', **kwargs)\n\n\n# The `Dependency.proxy.CurrentDependencyProxy.wrap` method to get\n# a correctly type-hinted (for IDE) proxy back:\ns3 = S3.proxy()\n</code></pre> <p>You can import the proxy and use it as if it's the current S3 object:</p> <pre><code># This is the download_file.py file.\n\n# Import proxy object from my module (lower-case version)\nfrom .my_resources import s3\nimport sys\n\nif __name__ == '__main__':\n    file_name = sys.argv[0]\n    dest_path = sys.argv[1]\n\n    # Call normal attributes/properties/methods on it like normal,\n    # the `s3` proxy will forward them to the current/injected object.\n    s3.resource.Bucket(\"my-bucket\").download_file(file_name, dest_path)\n</code></pre> <p>You can use the proxy object like a normal object.</p> <p>The only things not forwarded are any method/attribute that starts with a <code>_</code>, which conveays the attribute as private/internal.</p> <p>This includes any dunder-methods, they are not forarded either.</p> <p>Only use the proxy object for normal attribute/properties/methods.</p> <p>If you need do use an attribute/method that starts with an underscore <code>_</code>, grab the current object directly via <code>S3.grab()</code>.</p> <p>The <code>grab()</code> method returns the current real object each time it's called (and not a proxy).</p>"},{"location":"thread-safety/","title":"Thread Safety","text":"<p>There is a concept of an app-root, and thread-root <code>XContext</code>. The app-root stores dependecies that can be shared between threads, whule the thread-root context stores dependence for a specific thread.</p> <p>By default, each Dependency subclass can be shared between different threads, ie: it's assumed to be thread-safe.</p> <p>You can indicate a Dependency subclass should not be shared between threads by inheriting from <code>xinject.dependency.DependencyPerThread</code> instead, or by setting the class attribute (on your subclass of Dependency) <code>thread_sharable</code> to <code>False</code>; ie:</p> <pre><code>from xinject import Dependency, DependencyPerThread\n\nclass MyThreadUnsafeDependencyOpt1(DependencyPerThread):\n    ...\n\nclass MyThreadUnsafeDependencyOpt2(Dependency, thread_sharable=False):\n    ...\n</code></pre> <p>Things that are probably not thread-safe in general are resources that contain network/remote type connections/sessions/clients.</p> <p>Example for which you would want a separate dependency instance/object per-thread:</p> <ul> <li><code>requests</code> library session</li> <li>Requests libraries session object is not thread-safe, there is issue that's been around for 7 years     to make it thread safe that's still open. For now, you need a seperate requests Session per-thread.</li> <li><code>requests-mock</code> also needs the session created after it's setup, so after unit test runs.</li> <li>boto client/dependency</li> <li>Library says it's not thread-safe, you need to use a different object per-thread.</li> <li>Moto mocking library for AWS services needs you to allocate a client after it's setup,     (so lazily allocate client/dependency from boto).</li> </ul>"},{"location":"unit-testing/","title":"Unit Testing","text":""},{"location":"unit-testing/#overview-pytest","title":"Overview - pytest","text":"<p>Library has a pytest plugin, with the objective of clearing out dependencies at the start of each unit test run.</p> <p>This use useful when session/clients needs to be created after a mock installed. If the code-base uses a Dependency to grab a requests-session (for example), when a new unit-test runs it will allocate a new requests session, and mock will therefore work and start out blank, ready to be configured by the unit-test function that is currently running.</p> <p>While at the same time the code in prod/deployed code it will just use a shared session via the dependency, as that will stick around between lambda events, and so on and allow code to reuse already established connections (which is what you want to happen in deployed code).</p> <p>All you need to do is write a normal unit-test to take advantage of this feature:</p> <pre><code># This is the \"my_library/my_resources.py\" file/module.\n\nimport boto3\nfrom xinject import DependencyPerThread\n\n\nclass S3(DependencyPerThread):\n    def __init__(self, **kwargs):\n        # Keeping this simple; a more complex version\n        # may store the `kwargs` and lazily create the s3 resource\n        # only when it's asked for (via a `@property or some such).\n\n        self.resource = boto3.resource('s3', **kwargs)\n</code></pre> <pre><code># This is the \"my_library/my_functions.py\" file/module\n\nfrom .my_resources import S3\ndef download_file(file_name, dest_path):\n    S3.grab().resource.Bucket('my-bucket').download_file(\n        file_name, dest_path\n    )\n</code></pre> <pre><code># This is a unit-testing file/module\n\nfrom my_library.my_resources import S3\nfrom my_library.my_functions import download_file\nfrom moto import mock_s3\nimport tempfile\nimport pytest\n\n@mock_s3\n@pytest.mark.parametrize(\n    \"test_file\",\n    [\"a-file-1.txt\", \"a-file-2.txt\"],\n)\ndef test_download_file(test_file):\n    \"\"\"\n    `test_download_file` will be executed twice, once for each\n    parameterized value.\n\n    At the start of each run of the `test_download_file` function\n    (once for each parameterized value), the dependencies are cleared.\n\n    This means `S3.grab()` will create a S3 resource for me lazily\n    each time this unit-test function runs.\n\n    And so I can have separate, independent tests that won't leak\n    dependencies into the next function test-run.\n    \"\"\"\n\n    S3.grab().resource.Bucket('my-bucket').put_object(\n        Key=test_file,\n        Body=b'some-bytes'\n    )\n\n    with tempfile.NamedTemporaryFile() as tmp:\n        download_file(test_file, tmp.name)\n        with open(tmp.name, 'r') as file:\n            assert file.read() == b'some-bytes'\n</code></pre>"},{"location":"unit-testing/#implementation-details","title":"Implementation Details","text":"<p>This is just extra info in case your intrested.</p> <p>Before the start of each pytest unit-test function run, the current dependencies are deactivated and a new blank XContext (which contains the dependencies) is created.</p> <p>This means that by default, at the start of each running unit test function there will be no dependencies 'visible'.</p> PyTest Plugin Details <p>This project contains a pytest plugin to automatically install a brand-new app-root and thread-root XContext's  at the start of each unit test run.     </p> <p>This is important, it ensures a blank root-context is used each time a unit test executes.</p> <p>This is accomplished via an <code>autouse=True</code> fixture.</p> <p>The fixture is in a pytest plugin module. This plugin module is automatically found and loaded by pytest. pytest checks all installed dependencies in the environment it runs in, so as long as xinject is installed in the environment as a dependency it will find this and autoload this fixture for each unit test.</p> <p>If curious The <code>xinject_test_context</code> fixture is how it's implemented.</p> <p>The result is for each unit test executed via pytest, it will always start with no resources from a previous unit-test execution. So no dependencies changes/state will 'leak' between each unit test function run.</p> <p>Each unit-test will therefore always start out in the same state. This allows each unit test to run in any order, as it should not affect the dependencies of the next unit-test function that runs.</p>"}]}